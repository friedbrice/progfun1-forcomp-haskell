module SentenceAnagrams
( Sentence
, Word
, sentenceAnagrams
) where

import Prelude hiding (subtract, Word)

import Data.Char (toLower)
import Data.List (nub, subsequences)
import LinuxWords (linuxWords)

import qualified Data.Map.Lazy as Map

type Word = String
type Sentence = [Word]
type Occurrences = Map.Map Char Int

combine :: Occurrences -> Occurrences -> Occurrences
-- ^ Associative and commutative addition of two 'Occurrences's.
combine = Map.unionWith (+)

subtract :: Occurrences -> Occurrences -> Occurrences
-- ^ Subtract the right 'Occurrences' from the left 'Occurrences'.
subtract m1 m2 = Map.filter (> 0)
  $ foldr (\(c, n) -> Map.adjust (\i -> i - n) c) m1
  $ Map.toList m2

makeString :: Occurrences -> Word
-- ^ Returns a (probably) non-sense 'String' that is a preimage of the
--   supplied 'Occurrences' under 'wordOccurrences'.
makeString occ = Map.toList occ >>= \(c, n) -> replicate n c

dictionary :: [Word]
-- ^ Admissible words.
dictionary = linuxWords

charOccurrences :: Char -> Occurrences
-- ^ From a 'Char', derive a singleton 'Occurrences'.
charOccurrences c = Map.singleton (toLower c) 1

wordOccurrences :: Word -> Occurrences
-- ^ From a 'Word', generate an 'Occurrences'.
wordOccurrences = foldr (combine . charOccurrences) Map.empty

sentenceOccurrences :: Sentence -> Occurrences
-- ^ From a 'Sentence', generate an 'Occurrences'.
sentenceOccurrences = foldr (combine . wordOccurrences) Map.empty

dictionaryByOccurrences :: Map.Map Occurrences [Word]
-- ^ Associates to each 'Occurrences' the list of dictionary 'Word's
--   that generate that 'Occurrences'. Inverse mapping of
--   'wordOccurrences' restricted to 'dictionary'.
dictionaryByOccurrences = Map.fromList $ map getFiber allOccurrences
  where
    occurrencesByWord = map (\w -> (w, wordOccurrences w)) dictionary
    allOccurrences = map snd occurrencesByWord
    getFiber occ = (occ, fiber)
      where
        fiber = map fst $ filter ((== occ) . snd) occurrencesByWord

wordLookup :: Occurrences -> [Word]
-- ^ Interface to 'dictionaryByOccurrences'.
wordLookup occ = Map.findWithDefault [] occ dictionaryByOccurrences

wordAnagrams :: Word -> [Word]
-- ^ Find all single-word anagrams of the provided 'Word'.
wordAnagrams = wordLookup . wordOccurrences

combinations :: Occurrences -> [Occurrences]
-- ^ Returns the ideal generated by the supplied 'Occurrences'.
combinations = nub
  . map wordOccurrences
  . subsequences
  . makeString

extend :: (Sentence, Occurrences) -> [(Sentence, Occurrences)]
-- ^ Returns all possible extentions of the supplied 'Sentence' using
--   all or part of the supplied 'Occurrences', along with the
--   remainder of the 'Occurrences'.
extend (sent, occ) = filter prune $ map appendWord potentialWords
  where
    potentialWords = combinations occ >>= wordLookup
    appendWord w = (sent ++ [w], occ `subtract` wordOccurrences w)
    prune (_, o) = o == Map.empty || (combinations o >>= wordLookup) /= []

sentenceAnagrams :: Sentence -> [Sentence]
-- ^ Returns the list of all possible 'Sentence's that can be formed
--   using the characters of the supplied 'Sentence'.
sentenceAnagrams s = helper [] [([], sentenceOccurrences s)]
  where
    helper :: [Sentence] -> [(Sentence, Occurrences)] -> [Sentence]
    helper acc rest = case rest of
      [] -> acc
      _ -> let
        done = filter ((== Map.empty) . snd) rest
        newAcc = acc ++ map fst done
        notDone = filter ((/= Map.empty) . snd) rest
        newRest = notDone >>= extend
        in helper newAcc newRest
